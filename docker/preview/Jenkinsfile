// todo use it when border settings for handling `-k8s` suffix will be prepared
// def sandbox = params.sandbox_name.endsWith("-k8s") ?  params.sandbox_name : params.sandbox_name + '-k8s';
def sandbox = "preview";
def datacenter = params.datacenter
def environment = "preview"

def kubectlImage = "artifactory.wikia-inc.com/ops/k8s-deployer:0.0.15"
def nginxImage = "artifactory.wikia-inc.com/sus/mediawiki-sandbox-nginx"
def mediawikiImage = "artifactory.wikia-inc.com/sus/mediawiki-php"

def rolloutStatus = 1

def render(String template, java.util.LinkedHashMap binding) {
  def engine = new groovy.text.SimpleTemplateEngine()

  return engine.createTemplate(template).make(binding).toString()
}

def bump_minor(String prevMajorVersion, String prevTag) {
  prevMinorVersion = prevTag.tokenize('.')[1].replaceFirst("^0*", "")

  nextMinorVersion = (prevMinorVersion.toInteger() + 1).toString().padLeft(3, '0')

  return "${prevMajorVersion}.${nextMinorVersion}"
}

// tag: release-751.001
// version: 751.001
// branch: release-751

// for preview releases:
// starts with "1.001" when previous tags do not exist
// results in release branch version , eg. for branch "release-24"
// it will be "24.001", when tag corresponding to current release branch does not exist
// results in minor 1, eg. "23.001" => "23.002", when:
//   - tag for current release exists
//   - OR when it's not possible to retrieve release version from branch (e.g. "master")

// `git describe --abbrev=10 --always` returns
// - <latest-tag>-<number-of-commits-since-last-tag>-<10-chars-hash-of-last-commit> - when something was added since last tagged commit
// - <latest-tag> - when last commit is the tagged one
// - <full-commit hash> - when tag does not exist
def generateReleaseVersion(String branchName) {
  // get most recent tag reachable from commit
  // eg. release-757.001-12-ga0e0e73245 -> 757.001
  prevTag = sh(script: "git describe --abbrev=10 --always", returnStdout: true)
    .trim()
    .tokenize('-')[1]

  return prevTag

  // Disabled for now so we can run it right after old release pipeline for now

  // // retrieve release version from release branch eg. 757
  // tagFromBranch = branchName.tokenize('-')[1]

  // if (!prevTag.isEmpty()) {
  //   prevMajorVersion = prevTag.tokenize('.')[0]// eg. 34

  //   // fallback - if it's not possible to retrieve version from release branch, set it to previous major version
  //   if (tagFromBranch.isEmpty()) {
  //     tagFromBranch = prevMajorVersion
  //   }

  //   if (tagFromBranch <= prevMajorVersion) {
  //     return bump_minor(prevMajorVersion, prevTag)
  //   } else {
  //     return "${tagFromBranch}.001"
  //   }
  // } else {
  //   return "1.001"
  // }
}

def createReleaseBranch(String releaseBranch) {
  sh(script: "git checkout ${releaseBranch} || git checkout -b ${releaseBranch}")
  //TODO: uncomment when this will become main deploy pipeline
  // sh(script: "git push --set-upstream origin ${releaseBranch}")
}

// tag: release-xxx.xxx
def createTag(String tag) {
  doesTagExist = sh(script: "git tag --list ${tag}", returnStdout: true).trim()

  if (!doesTagExist.isEmpty()) {
    println("Creating ${tag} tag")
    sh(script: "git tag --annotate --message ${tag} ${tag}")
    sh(script: "git push origin ${tag}")
  } else {
    println("Tag ${tag} already exists")
  }
}

def notifyBuild(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "!!K8S (mirror deploy)!!: *${buildStatus}*: <${env.BUILD_URL}|${env.JOB_NAME}. Build #${env.BUILD_NUMBER}>"
  def summary = "${subject}"

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'BLUE'
    colorCode = '#70CADB'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#7AF371'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
    summary = summary + " <!here>"
  }

  // Send notifications
  slackSend (channel: '#release-progress', color: colorCode, failOnError: true, message: summary)
}

stage('Slack notify start') {
  // notifyBuild('STARTED')
}

node("docker-daemon") {
  def imageExists = false
  def buildUser = "Anonymous"
  def appHash
  def configHash
  def imageTag

  def appReleaseVersion
  def appReleaseTag
  def appReleaseBranch

  def configReleaseVersion
  def configReleaseTag
  def configReleaseBranch

  wrap([$class: 'BuildUser']) {
    try {
      buildUser = "${BUILD_USER}"
    } catch (MissingPropertyException ex) {
      buildUser = "Jenkins"
    }
  }

  try {
    stage('Upload, download and push translations to dev') {
      //TODO: uncomment when this will become main deploy pipeline
      //Disabled for now, so we don't do it twice (when deploying to Apaches and when deploying to k8s)

      // node('sandbox-i18n01') {
      //   sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
      //       git branch: 'dev',
      //         credentialsId: 'bd3cf712-39a7-4b16-979e-ff86208ab2ea',
      //         url: 'git@github.com:Wikia/app.git'

      //       sh '''
      //       git clean -f
      //       git pull origin dev
      //       git config --global user.email 'jenkins@fandom.com'
      //       git config --global user.name 'Sir Jenkins'
      //       sudo /usr/local/bin/downloadAppMasterTranslations.sh
      //       git add --all
      //       git diff --quiet --exit-code --cached || git commit -m 'Automatic translations update'
      //       git push -u origin dev
      //       '''
      //   }
      // }
    }

    stage("Clone repositories") {
      parallel (
        "app": {
          dir("app") {
            git url: "git@github.com:Wikia/app.git",
              branch: 'dev',
              credentialsId: "bd3cf712-39a7-4b16-979e-ff86208ab2ea"
          }
        },
        "config": {
          dir("config") {
            git url: "git@github.com:Wikia/config.git",
              branch: 'dev',
              credentialsId: "bd3cf712-39a7-4b16-979e-ff86208ab2ea"
          }
        }
      )
    }

    stage("Calculate next release branch and version") {
      dir("app") {
        appReleaseVersion = generateReleaseVersion()
        appReleaseTag = "release-" + appReleaseVersion
        appReleaseBranch = appReleaseTag.tokenize('.')[0]
      }

      dir("config") {
        configReleaseVersion = generateReleaseVersion()
        configReleaseTag = "release-" + configReleaseVersion
        configReleaseBranch = configReleaseTag.tokenize('.')[0]
      }
    }

    stage("Fetch version") {
      def deploymentInfo

      withDockerContainer(kubectlImage) {
        deploymentInfo = sh(
          script: "kubectl --context kube-${datacenter}-prod -n prod get deployments -l app=mediawiki-preview -o jsonpath='{.items[0].spec.template.metadata.labels}'",
          returnStdout: true
        )
      }

      def prevConfigVersion = sh(script: "echo \"${deploymentInfo}\" | sed 's/.*config_version:\\([^] ]*\\).*/\\1/'", returnStdout: true)
      def prevAppVersion = sh(script: "echo \"${deploymentInfo}\" | sed 's/.*app_version:\\([^] ]*\\).*/\\1/'", returnStdout: true)

      if (params.force != true) {
        timeout(time: 120, unit: 'SECONDS') {
          userInput = input(
            id: 'version_check',
            message: "Updating preview\napp - ${prevAppVersion} ==> ${appReleaseVersion} \nconfig - ${prevConfigVersion} ==> ${configReleaseVersion}"
          )
        }
      }
    }

    stage("Create new release branches") {
      sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
        dir("app") {
          createReleaseBranch(appReleaseBranch)
        }

        dir("config") {
          createReleaseBranch(configReleaseBranch)
        }
      }
    }

    stage("Create release tags") {
      sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
        dir("app") {
          //TODO: uncomment when this will become main deploy pipeline
          // createTag(appReleaseTag)
        }

        dir("config") {
          //TODO: uncomment when this will become main deploy pipeline
          // createTag(configReleaseTag)
        }
      }
    }

    stage("Calculate docker image tag") {
      dir("app") {
        appHash = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()

        println("Wikia/app commit: $appHash")
      }

      dir("config") {
        configHash = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()

        println("Wikia/config commit: $configHash")
      }

      imageTag = "$appHash.$configHash"

      println("Image tag: $imageTag")
    }

    stage("Bump cachebuster and version") {
      dir("app") {
        sh('echo "<?php\n\\\$wgStyleVersion = "$(date +%s)";" > wgStyleVersion.php')
        sh('echo "' + appReleaseTag + '@' + appHash + '" > wikia.version.txt')
      }

      dir("config") {
        sh('echo "' + configReleaseTag + '@' + configHash + '" > wikia.version.txt')
      }
    }

    stage("Build and push php image") {
      dir("app") {
        def status = sh(script: """
          curl -u ${env.JENKINS_ARTIFACTORY_USERNAME}:${env.JENKINS_ARTIFACTORY_PASSWORD} \
          -w "%{http_code}" -s -I -o /dev/null \
          -XGET "https://artifactory.wikia-inc.com/artifactory/api/storage/dockerv2-local/sus/mediawiki-php/${imageTag}"
        """, returnStdout: true).trim()

        if (status == "200") {
          imageExists = true
        }

        if (!imageExists) {
          // SUS-5284 - make the image a bit smaller
          sh("cp docker/.dockerignore ..")
          sh("docker build .. -f docker/base/Dockerfile-php -t $mediawikiImage:$imageTag")
          sh("docker push $mediawikiImage:$imageTag")
        } else {
          println("Php image tag ($imageTag) already exists")
        }
      }
    }

    stage("Build and push nginx image") {
      dir("app") {
        def status = sh(script: """
          curl -u ${env.JENKINS_ARTIFACTORY_USERNAME}:${env.JENKINS_ARTIFACTORY_PASSWORD} \
          -w "%{http_code}" -s -I -o /dev/null \
          -XGET "https://artifactory.wikia-inc.com/artifactory/api/storage/dockerv2-local/sus/mediawiki-sandbox-nginx/${imageTag}"
        """, returnStdout: true).trim()

        if (status == "200") {
          imageExists = true
        }

        if (!imageExists) {
          // SUS-5284 - make the image a bit smaller
          sh("cp docker/.dockerignore ..")
          sh("docker build  . -f docker/sandbox/Dockerfile-nginx -t $nginxImage:$imageTag")
          sh("docker push $nginxImage:$imageTag")
        } else {
          println("Nginx image tag ($imageTag) already exists")
        }
      }
    }

    stage('Notify Slack Channel publish') {
      sh "curl -X POST -H 'Content-type: application/json' --data '{ \"text\": \"MediaWiki with app commit <https://github.com/Wikia/app/commit/'${appHash}'|'${appHash}'> and config commit <https://github.com/Wikia/config/commit/'${configHash}'|'${configHash}'> is published by '${buildUser}'\", \"channel\": \"'${env.MW_SANDBOX_K8S_CHANNEL}'\" }' '${env.MW_SANDBOX_K8S_WEBHOOK}'"
    }

    stage("Apply new k8s descriptor") {
      dir("app") {
        def template = sh(script: 'cat docker/sandbox/sandbox.template.yaml', returnStdout: true)
        def k8s = render(template, [
          'IMAGE_TAG': imageTag,
          'SANDBOX_NAME': 'preview',
          'SANDBOX_ENVIRONMENT': 'preview',
          'SANDBOX_DATACENTER': datacenter,
          'APP_VERSION': params.app_branch,
          'CONFIG_VERSION': params.config_branch,
          'REPLICAS': 4
        ])

        sh("""cat > docker/sandbox/k8s.yaml <<EOL
  ${k8s}
  EOL""")

        sh("cat docker/sandbox/k8s.yaml")
      }

      withDockerContainer(kubectlImage) {
        sh "kubectl --context kube-${datacenter}-prod -n prod apply -f app/docker/sandbox/k8s.yaml"
        rolloutStatus = sh(returnStatus: true, script: "kubectl --context kube-${datacenter}-prod -n prod rollout status deployment/mediawiki-preview")
      }
    }

    stage('Create selenium-tests preview branch') {
      //TODO: uncomment when this will become main deploy pipeline
      // build 'create-preview-test-run'
    }

    stage('Tag Jira tickets') {
      //TODO: uncomment when this will become main deploy pipeline
      // build job: 'tag-jira-tickets', parameters: [
      //     string(name: 'app_name', value: 'app'),
      //     string(name: 'env', value: 'preview'),
      //     string(name: 'previous_release', value: prevAppVersion),
      //     string(name: 'current_release', value: params.app),
      //     [$class: 'LabelParameterValue', name: 'node', label: 'linux']
      // ],
      // wait: false
    }

    stage('Trigger tests') {
      //TODO: uncomment when this will become main deploy pipeline
      // build job: 'app-preview-push-event', parameters: [
      //   string(name: 'release', value: params.app),
      //   string(name: 'datacenter', value: 'sjc')],
      //   wait: false
    }

    stage("Set and report job status") {
      def emoji
      def color
      if (rolloutStatus != 0) {
        currentBuild.result = "UNSTABLE"
        emoji = ":siren:"
        color = "#cc142c"
      } else {
        emoji = ":checkmark:"
        color = "#36a64f"
      }

      sh "curl -X POST -H 'Content-type: application/json' --data '{ \"mrkdwn_in\": [\"pretext\", \"text\"], \"color\": \"${color}\", \"pretext\": \"${emoji} MediaWiki rollout status\", \"channel\": \"${env.MW_SANDBOX_K8S_CHANNEL}\", \"fields\": [ {\"title\": \"sandbox\", \"value\": \"${sandbox}\", \"short\": true } ] }' ${env.MW_SANDBOX_K8S_WEBHOOK}"
    }

  } catch (e) {
    // If there was an exception thrown, the build failed
    currentBuild.result = "FAILED"
    throw e
  } finally {
    stage('Set and report job status') {
      if (rolloutStatus != 0) {
        currentBuild.result = "UNSTABLE"
      }

      // notifyBuild(currentBuild.result)
    }
  }
}
