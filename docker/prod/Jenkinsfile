def kubectlImage = "artifactory.wikia-inc.com/ops/k8s-deployer:0.0.15"
def nginxImage = "artifactory.wikia-inc.com/sus/mediawiki-prod-nginx"
def mediawikiImage = "artifactory.wikia-inc.com/sus/mediawiki-php"
def loggerImage = "artifactory.wikia-inc.com/sus/mediawiki-logger"

def rolloutStatusSjc = 1
def rolloutStatusRes = 1

def slackChannel = "#mw-prod-deployment"

def render(String template, java.util.LinkedHashMap binding) {
  def engine = new groovy.text.SimpleTemplateEngine()

  return engine.createTemplate(template).make(binding).toString()
}

// tag: release-xxx.xxx
def createTag(String tag) {
  doesTagExist = sh(script: "git tag --list ${{tag}}", returnStdout: true).trim()

  if (!doesTagExist.isEmpty()) {
    println("Creating ${{tag}} tag")
    sh(script: "git tag --annotate --message ${{tag}} ${{tag}}")
    sh(script: "git push origin ${{tag}}")
  } else {
    println("Tag ${{tag}} already exists")
  }
}

def messageDetails(int rolloutStatus) {
  if (rolloutStatus != 0) {
    return [
      emoji: ":siren:",
      color: "#cc142c"
    ]
  } else {
    return [
      emoji: ":checkmark:",
      color: "#36a64f"
    ]
  }
}

def notifyBuild(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "!!K8S (mirror deploy)!!: *${buildStatus}*: <${env.BUILD_URL}|${env.JOB_NAME}. Build #${env.BUILD_NUMBER}>"
  def summary = "${subject}"

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'BLUE'
    colorCode = '#70CADB'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#7AF371'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
    summary = summary + " <!here>"
  }

  // Send notifications
  slackSend (channel: '#release-progress', color: colorCode, failOnError: true, message: summary)
}

stage('Slack notify start') {
  notifyBuild('STARTED')
}

node("docker-daemon") {
  def currentAppBranch
  def currentConfigBranch
  def currentAppTag
  def currentConfigTag

  def nextAppBranch
  def nextConfigBranch
  def nextAppTag
  def nextConfigTag

  def buildUser = "Anonymous"
  def imageExists = false
  def appHash
  def configHash
  def imageTag

  wrap([$class: 'BuildUser']) {
    try {
      buildUser = "${BUILD_USER}"
    } catch (MissingPropertyException ex) {
      buildUser = "Jenkins"
    }
  }

  try {
    stage('Fetch version') {
      def deploymentInfo

      // when from preview fetch version from preview
      // when from hotfix fetch version from prod

      if (params.source == 'preview') {
        withDockerContainer(kubectlImage) {
          previewDeploymentInfo = sh(
            script: "kubectl --context kube-sjc-prod -n prod get deployments -l app=mediawiki-preview -o jsonpath='{.items[0].spec.template.metadata.labels}'",
            returnStdout: true
          )
        }

        nextAppTag = sh(
          script: "echo \"${previewDeploymentInfo}\" | sed 's/.*app_version:\\([^] ]*\\).*/\\1/'",
          retunStdout: true
        )
        nextConfigTag = sh(
          script: "echo \"${previewDeploymentInfo}\" | sed 's/.*config_version:\\([^] ]*\\)r.*/\\1/'",
          returnStdout: true
        )

        nextAppBranch = nextAppTag.split('.')[0]
        nextConfigBranch = nextConfigTag.split('.')[0]
      }

      withDockerContainer(kubectlImage) {
        currentDeploymentInfo = sh(
          script: "kubectl --context kube-sjc-prod -n prod get deployments -l app=mediawiki-prod -o jsonpath='{.items[0].spec.template.metadata.labels}'",
          returnStdout: true
        )
      }

      currentAppTag = sh(
        script: "echo \"${currentDeploymentInfo}\" | sed 's/.*app_version:\\([^] ]*\\).*/\\1/'",
        returnStdout: true
      )
      currentConfigTag = sh(
        script: "echo \"${currentDeploymentInfo}\" | sed 's/.*config_version:\\([^] ]*\\).*/\\1/'",
        returnStdout: true
      )

      currentAppBranch = currentAppTag.split('.')[0]
      currentConfigBranch = currentConfigTag.split('.')[0]
    }

    stage("Clone repositories") {
      def appBranch = currentAppBranch
      def configBranch = currentConfigBranch

      if (nextAppBranch) {
        appBranch = nextAppBranch
      }

      if (nextConfigBranch) {
        configBranch = nextConfigBranch
      }

      dir("app") {
        git url: "git@github.com:Wikia/app.git",
            branch: appBranch,
            credentialsId: "bd3cf712-39a7-4b16-979e-ff86208ab2ea"

        //todo: if the same release branch create new tag

        createTag(nextAppTag)

        appHash = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()

        println("Wikia/app commit: $appHash")
      }

      dir("config") {
        git url: "git@github.com:Wikia/config.git",
            branch: configBranch,
            credentialsId: "bd3cf712-39a7-4b16-979e-ff86208ab2ea"

        //todo: if the same release branch create new tag
        createTag(nextConfigTag)

        configHash = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()

        println("Wikia/config commit: $configHash")
      }

      imageTag = "$appHash.$configHash"

      println("Image tag: $imageTag")
      println("App Tag: $nextAppTag")
      println("Config Tag: $nextConfigTag")
    }

    stage("Calculate next tag") {

    }

    stage("Prompt for a version") {
      if (params.force != true) {
        timeout(time: 120, unit: 'SECONDS') {
          userInput = input(
            id: 'version_check',
            message: "Updating\napp - ${currentAppTag} ==> ${nextAppTag} \nconfig - ${currentConfigTag} ==> ${nextConfigTag}"
          )
        }
      }
    }

    stage("Bump cachebuster and version") {
      dir("app") {
        def cacheBuster = new Date().getTime()

        sh('echo "<?php\n\\\$wgStyleVersion = ' + cacheBuster + ';" > wgStyleVersion.php')
        sh('echo "' + appBranch + '@' + appHash + '" > wikia.version.txt')
      }

      dir("config") {
        sh('echo "' + configBranch + '@' + configHash + '" > wikia.version.txt')
      }
    }

    stage("Build and push php image") {
      dir("app") {
        def status = sh(script: """
          curl -u ${env.JENKINS_ARTIFACTORY_USERNAME}:${env.JENKINS_ARTIFACTORY_PASSWORD} \
          -w "%{http_code}" -s -I -o /dev/null \
          -XGET "https://artifactory.wikia-inc.com/artifactory/api/storage/dockerv2-local/sus/mediawiki-php/${imageTag}"
        """, returnStdout: true).trim()

        if (status == "200") {
          imageExists = true
        }

        if (!imageExists) {
          // SUS-5284 - make the image a bit smaller
          sh("cp docker/.dockerignore ..")
          sh("docker build .. -f docker/base/Dockerfile-php -t $mediawikiImage:$imageTag")
          sh("docker push $mediawikiImage:$imageTag")
        } else {
          println("Php image tag ($imageTag) already exists")
        }
      }
    }

    stage("Build and push nginx image") {
      dir("app") {
        def status = sh(script: """
          curl -u ${env.JENKINS_ARTIFACTORY_USERNAME}:${env.JENKINS_ARTIFACTORY_PASSWORD} \
          -w "%{http_code}" -s -I -o /dev/null \
          -XGET "https://artifactory.wikia-inc.com/artifactory/api/storage/dockerv2-local/sus/mediawiki-prod-nginx/${imageTag}"
        """, returnStdout: true).trim()

        if (status == "200") {
          imageExists = true
        }

        if (!imageExists) {
          // SUS-5284 - make the image a bit smaller
          sh("cp docker/.dockerignore ..")
          sh("docker build . -f docker/prod/Dockerfile-nginx -t $nginxImage:$imageTag")
          sh("docker push $nginxImage:$imageTag")
        } else {
          println("Nginx image tag ($imageTag) already exists")
        }
      }
    }

    stage('Notify Slack Channel publish') {
      sh "curl -X POST -H 'Content-type: application/json' --data '{ \"text\": \"MediaWiki with app branch <https://github.com/Wikia/app/tree/'${appBranch}'|'${appBranch}'> and config branch <https://github.com/Wikia/config/tree/'${configBranch}'|'${configBranch}'> is published by '${buildUser}'\", \"channel\": \"'${slackChannel}'\" }' '${env.MW_SANDBOX_K8S_WEBHOOK}'"
    }

    stage("Apply new k8s descriptor") {
      dir("app") {
        def template = sh(script: 'cat docker/prod/prod.template.yaml', returnStdout: true)
        def sjc = render(template, [
          'IMAGE_TAG': imageTag,
          'DATACENTER': 'sjc',
          'APP_VERSION': nextAppTag,
          'CONFIG_VERSION': nextConfigTag
        ])

        sh("""cat > docker/prod/sjc.yaml <<EOL
  ${sjc}
  EOL""")

        def res = render(template, [
          'IMAGE_TAG': imageTag,
          'DATACENTER': 'res',
          'APP_VERSION': nextAppTag,
          'CONFIG_VERSION': nextConfigTag
        ])

        sh("""cat > docker/prod/res.yaml <<EOL
  ${res}
  EOL""")
      }

      withDockerContainer(kubectlImage) {
        // deploy to SJC
        sh "kubectl --context kube-sjc-prod -n prod apply -f app/docker/prod/sjc.yaml"
        rolloutStatusSjc = sh(returnStatus: true, script: "kubectl --context kube-sjc-prod -n prod rollout status deployment/mediawiki-prod")

        // deploy to RES
        sh "kubectl --context kube-res-prod -n prod apply -f app/docker/prod/res.yaml"
        rolloutStatusRes = sh(returnStatus: true, script: "kubectl --context kube-res-prod -n prod rollout status deployment/mediawiki-prod")
      }
    }

    stage("Apply cron jobs") {
      dir("app") {
        // SUS-5531 - apply cron jobs via auto-generated YAML file
        sh("cd docker/maintenance && bash cronjobs-generator.sh ${imageTag} > ../prod/k8s-cronjobs.yaml")
        sh("cat docker/prod/k8s-cronjobs.yaml")
      }

      withDockerContainer(kubectlImage) {
        // cron jobs only run on SJC
        sh "kubectl --context kube-sjc-prod -n prod apply -f app/docker/prod/k8s-cronjobs.yaml"
      }
    }

    stage('Tag Jira tickets') {{
      build job: 'tag-jira-tickets', parameters: [
        string(name: 'app_name', value: 'app'),
        string(name: 'env', value: 'prod'),
        string(name: 'previous_release', value: currentAppVersion),
        string(name: 'current_release', value: nextAppVersion),
        [$class: 'LabelParameterValue', name: 'node', label: 'linux']
      ],
      wait: false
    }}

    stage('Trigger tests') {
      build job: 'app-prod-push-event', parameters: [
        string(name: 'release', value: nextAppVersion),
        string(name: 'datacenter', value: 'sjc')
      ],
        wait: false
    }

  } catch (e) {
    // If there was an exception thrown, the build failed
    currentBuild.result = "FAILED"
    throw e
  } finally {
    stage('Set and report job status') {
      if (rolloutStatusSjc != 0 || rolloutStatusRes != 0) {
        currentBuild.result = "UNSTABLE"
      }

      notifyBuild(currentBuild.result)
    }
  }
}
